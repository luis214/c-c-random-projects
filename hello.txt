#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <sstream>

using namespace std;



struct attr {
	string name;
	string value;
};
struct tag {
	string name;
    bool open;
	vector<attr> attributes;
}; 

void parse_lines(int);
void parse_queries(int);
string parse_qhelper(string, string);
void insert_vector(tag);

vector<vector<tag>> tags;

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int N, Q;
    cin >> N;
    cin >> Q;
    cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    
    if((N >= 1 && N <= 20) && (Q >= 1 && Q <= 20))
    {
        parse_lines(N);
        //cout << endl << tags.size() << endl;
        /*for(int i = 0; i < tags.size(); ++i){
            
            cout << endl << tags[i].size() << endl;
            
            for(int j = 0; j < tags[i].size(); ++j){
               
                for(size_t k = 0; k < tags[i][j].attributes.size(); ++k)
                {
                    cout << tags[i][j].attributes.size() << endl;    
                    cout << tags[i][j].attributes.at(k).name << endl;
                    cout << tags[i][j].attributes.at(k).value << endl;
                }
                 
                
            }
        }*/
        parse_queries(Q);
        
    }
    return 0;
}

void parse_queries(int Q)
{
    string line, temp, attribute, temp2;
    bool match = true;
    vector<string> vec_str; 
    
    for(int i = 0; i < Q; ++i)
    {
       getline(cin, line);
       for(int ix = 0; ix < tags.size(); ++ix)
       {
           stringstream ss(line);
           getline(ss, temp, '.');
           getline(ss, temp2, '~');
           if(tags[ix][0].name == temp || tags[ix][0].name == temp2)
           {
               
               for(int iy = 0; iy < tags[ix].size(); ++iy)
               {
                   line = parse_qhelper(tags[ix][iy].name, line);
                   cout << line << endl;
                   if(line == "match")
                   {
                        cout << "maybe";
                        for(int k = 0; k = tags[ix][iy].attributes.size(); ++k)
                        {
                            if(tags[ix][iy].attributes[k].name == line.substr(1))
                            {
                                cout << tags[ix][iy].attributes[k].value << endl;
                                match = true;
                                break;
                            }
                            else
                                match = false;
                        }
                        break;
                   }
                   else if(line == "no match")
                   {
                        match = false;
                        break;
                   }
               }
               break;
           }  
       }
       if(!match)
       {
           cout << "Not Found!\n";
       }
    }
}

string parse_qhelper(string tline, string qline)
{
    if(qline[0] == '~')
    {
        return "match";
    }
    if(qline[0] == '.')
    {
        cout << "x";
        return qline.substr(1);
    }
    if(qline[0] == tline[0])
    {
        parse_qhelper(tline.substr(1), qline.substr(1));
    }
    else 
      return "no match";
}
  

void insert_vector(tag t)
{
    for(int ix = tags.size() - 2; ix >= 0; --ix)
    {
        //cout << tags.size();
		if(tags[ix][0].open == true)
        {
            tags[ix].push_back(t);
        }
    }
}
void parse_lines(int N)
{
    string line;
    int current;
    vector<tag> vec_tag;
    tag t; 
    attr a;
    for(int i = 0; i < N; ++i)
    {
        getline(cin, line);
        if(line.size() <= 200)
        {
            if(line[0] == '<' && line[line.size()-1] == '>')
            {
                if(line[1] != '/')
                {
                    stringstream ss(line.substr(1));
                    string sub_line;
                    getline(ss,sub_line,' ');
                    t.name = sub_line;
                    t.open = true;
                    
                    if(sub_line[sub_line.size()-1] != '>')
                    {
                        while(sub_line != ">")
                        {
                            getline(ss,sub_line,' ');
                            a.name = sub_line;
                            getline(ss,sub_line,'"');
                            getline(ss,sub_line,'"');
                            a.value = sub_line;
                            t.attributes.push_back(a);
                            getline(ss,sub_line, ' ');
							
                        }
                       
                    }
                    else
                    {
                        getline(ss,sub_line,'>');
                       
                    }
				
                    tags.push_back(vector<tag>());
                    int current = tags.size() - 1;
                    //cout << "\n" << t.name << endl;
                    tags.at(current).push_back(t);
					//cout << "\nmade it3\n";
                    insert_vector(t);
                    t.attributes.clear();
				
                    
                    //tags.push_back(vec_tag);
                   
                }
                else
                {
                    stringstream ss(line.substr(2));
                    string sub_line;
                    getline(ss,sub_line,'>');
                    for(size_t j = 0; j < tags.size(); ++j)
                    {
                        if(tags[j][0].name == sub_line)
                        {
                            tags[j][0].open = false;
                        }
                    }
                }
               
            }
            else
                break;
        }
    }
}

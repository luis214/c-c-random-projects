#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <sstream>
#include <map>


using namespace std;



struct attr {
	string name;
	string value;
};
struct tag {
	vector<attr> attributes;
	vector<string> children_tags;
}; 

void parse_lines(int,int,string);
void parse_queries(int);


map<string,tag> tags;
vector<string> parent_tags;

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int N, Q;
    cin >> N;
    cin >> Q;
    cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    
    if((N >= 1 && N <= 20) && (Q >= 1 && Q <= 20))
    {
		parse_lines(N,0,"");
		
		/*FOR TESTING PURPOSES
		for (std::map<string,tag>::iterator it=tags.begin(); it!=tags.end(); ++it)
		{
			cout << it->first << " children: ";
			for(size_t i = 0; i < it->second.children_tags.size(); ++i)
			{
				cout << it->second.children_tags[i] << " ";
			}
			cout << endl;
		} 
		for(size_t i = 0; i < parent_tags.size(); i++)
		{
			cout << parent_tags[i] << endl;
		}*/
    }
    return 0;
}


string parse_queryhelper(string tline, string qline)
{
    if(qline[0] == '~')
    {
        return "match";
    }
    else if(qline[0] == '.')
    {
        return qline.substr(1);
    }
    else if(qline[0] == tline[0])
    {
		char q = qline[0];
		char t = tline[0];
		return parse_queryhelper(tline.substr(1), qline.substr(1));
    }
    else
        return "no match";
}
void parse_queries(int Q)
{
   
}

void parse_lines(int N, int total_lines, string prev_tag)
{
	if(total_lines < N)
	{
		
		++total_lines;
		string line;
		getline(cin,line);
		string current_tag;

		if(line[1] == '/')
		{
			bool found = false;
			stringstream ss(line.substr(2));
            getline(ss,current_tag,'>');
			for (std::map<string,tag>::iterator it=tags.begin(); it!=tags.end(); ++it)
			{
				for(size_t i = 0; i < it->second.children_tags.size(); ++i)
				{
					if(it->second.children_tags.at(i) == current_tag)
					{
						current_tag = it->first;
						found = true;
						break;
					}
				}
				if(found)
					break;
			}
			if(!found)
			{
				parent_tags.push_back(current_tag);
				current_tag.clear();
			}
			
		}
		else
		{
		
			stringstream ss(line.substr(1));
			
            string sub_line;
			tag t;
			attr a;
			getline(ss,current_tag,' ');
			if(current_tag[current_tag.size()-1] != '>')
            {

				while(sub_line != ">")
                {
                    getline(ss,sub_line,' ');
                    a.name = sub_line;
                    getline(ss,sub_line,'"');
                    getline(ss,sub_line,'"');
                    a.value = sub_line;
                    t.attributes.push_back(a);
                    getline(ss,sub_line, ' ');
                }
				
            }
            else
            {
                stringstream ss(line.substr(1));
				getline(ss,current_tag,'>');   
            }
			tags[current_tag] = t;

			if(!prev_tag.empty())
			{
				auto search = tags.find(prev_tag);
				if(search != tags.end()) 
				{
					search->second.children_tags.push_back(current_tag);
					
				} 
			}
		}

		parse_lines(N, total_lines, current_tag);
	}
}

  string line, temp, attribute, temp2;
    bool match;
    vector<string> vec_str; 
    
    for(int i = 0; i < Q; ++i)
    {
       getline(cin, line);
	   stringstream sx(line);
	   //cout << line << endl;
       for(int ix = 0; ix < tags.size(); ++ix)
       {;
		   stringstream ss(line);
           getline(ss, temp, '.'); //Parse until your reach .
           getline(sx, temp2, '~'); //Parse until you reach ~
		  
           if(tags[ix][0].name == temp || tags[ix][0].name == temp2)
           {
               
			   for(int iy = 0; iy < tags[ix].size(); ++iy)
               {
                   //cout << "maybe";
				   line = parse_queryhelper(tags[ix][iy].name, line);
                  // cout << line << endl;

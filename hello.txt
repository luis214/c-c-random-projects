#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <sstream>


using namespace std;



struct attr {
	string name;
	string value;
};
struct tag {
	string name;
    bool open;
	vector<attr> attributes;
	int steps;
}; 

void parse_lines(int);
void parse_queries(int);
string parse_queryhelper(string, string);
void insert_vector(tag);
void check();

vector<vector<tag>> tags;

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int N, Q;
    cin >> N;
    cin >> Q;
    cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    
    if((N >= 1 && N <= 20) && (Q >= 1 && Q <= 20))
    {
        parse_lines(N);
		check();
        //cout << endl << tags.size() << endl;
        for(int i = 0; i < tags.size(); ++i){
            
          //  cout << endl << tags[i].size() << endl;
			cout << tags[i][0].steps << " ";
            
            for(int j = 0; j < tags[i].size(); ++j){
               
				cout << tags[i][j].name <<  " { "; 
				for(size_t k = 0; k < tags[i][j].attributes.size(); ++k)
                {   
                    cout << tags[i][j].attributes.at(k).name << "=";
                    cout << tags[i][j].attributes.at(k).value << " ";
                }
				cout << " } ";
            }
			cout << "\n\n";
        }
        parse_queries(Q);
        
    }
    return 0;
}

void check()
{
	for(int i = 0; i < tags.size(); ++i)
	{
		tag t = tags[i][0];


		for(int k = 0; k < tags.size(); ++k)
		{
			for(int j = 0; j < tags[k].size(); ++j)
		    {
               
				if (tags[k][j].name == t.name)
				{
					tags[i][0].steps += 1;
				}
		    }	
		}     
	}
}
string parse_queryhelper(string tline, string qline)
{
    if(qline[0] == '~')
    {
        return "match";
    }
    else if(qline[0] == '.')
    {
        return qline.substr(1);
    }
    else if(qline[0] == tline[0])
    {
        return parse_queryhelper(tline.substr(1), qline.substr(1));
    }
    else
        return "no match";
}
void parse_queries(int Q)
{
    string line, temp, attribute, temp2;
    bool match;
    vector<string> vec_str; 
    
    for(int i = 0; i < Q; ++i)
    {
       getline(cin, line);
	   stringstream sx(line);
	   getline(sx, temp2, '~'); //Parse until you reach ~
	   //cout << line << endl;
       for(int ix = 0; ix < tags.size(); ++ix)
       {
		   stringstream ss(line);
           getline(ss, temp, '.'); //Parse until your reach .
           
		  
		   int p = tags[ix][0].steps;
		   if((tags[ix][0].name == temp || tags[ix][0].name == temp2) && tags[ix][0].steps < 2)
           {
               
			   for(int iy = 0; iy < tags[ix].size(); ++iy)
               {
                   //cout << "maybe";
				   line = parse_queryhelper(tags[ix][iy].name, line);
                  // cout << line << endl;
                   if(line == "match")
                   {
                        
                        getline(sx, temp2, ' ');
					    for(int k = 0; k < tags[ix][iy].attributes.size(); ++k)
                        {
							if(tags[ix][iy].attributes[k].name == temp2)
                            {
                                cout << tags[ix][iy].attributes[k].value << endl;
								//flush();
                                match = true;
								line.clear();
                                break;
                            }
                            else
                                match = false;
                        }
                        break;
                   }
                   else if(line == "no match")
                   {
                        match = false;
                        break;
                   }
               }
               break;
           }  
		   else
		   {
			  match = false;
		   }
       }
       if(!match)
       {
           cout << "Not Found!\n";
		   line.clear();
       }
    }
}
void insert_vector(tag t)
{
    for(int ix = tags.size() - 2; ix >= 0; --ix)
    {
        //cout << tags.size();
		if(tags[ix][0].open == true)
        {
            tags[ix].push_back(t);
        }
    }
}
void parse_lines(int N)
{
    string line;
    int current;
    vector<tag> vec_tag;
    tag t; 
    attr a;
    for(int i = 0; i < N; ++i)
    {
        getline(cin, line);
        if(line.size() <= 200)
        {
            if(line[0] == '<' && line[line.size()-1] == '>')
            {
                if(line[1] != '/')
                {
                    stringstream ss(line.substr(1));
                    string sub_line;
                    getline(ss,sub_line,' ');
                    t.name = sub_line;
                    t.open = true;
                    
                    if(sub_line[sub_line.size()-1] != '>')
                    {
                        while(sub_line != ">")
                        {
                            getline(ss,sub_line,' ');
                            a.name = sub_line;
                            getline(ss,sub_line,'"');
                            getline(ss,sub_line,'"');
                            a.value = sub_line;
                            t.attributes.push_back(a);
                            getline(ss,sub_line, ' ');
							//cout << "HEY";
							
                        }
                    }
                    else
                    {
                        stringstream ss(line.substr(1));
						getline(ss,sub_line,'>');
						t.name = sub_line;
						//cout << "NO: " << t.name << "\n";
                       
                    }
					t.steps = 0;
                    tags.push_back(vector<tag>());
                    int current = tags.size() - 1;
                    tags.at(current).push_back(t);
                    insert_vector(t);
                    t.attributes.clear();
                   
                }
                else
                {
                    stringstream ss(line.substr(2));
                    string sub_line;
                    getline(ss,sub_line,'>');
                    for(size_t j = 0; j < tags.size(); ++j)
                    {
                        if(tags[j][0].name == sub_line)
                        {
                            tags[j][0].open = false;
                        }
                    }
                }
               
            }
            else
                break;
        }
    }
}
